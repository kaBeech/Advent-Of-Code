# Day 5

## Xtreme Xmas Code Link

https://www.xtremexmascode.com/game/public/13/day/5/

### Challenge Modifier

"Your challenge is to write a program to complete today's puzzle while taking a 3-minute (minimum) break every 20 minutes"

Aww yeah! I'm gonna start by taking a break to get some food!

### Evidence

Number of Breaks: 7

### Points Earned

20

### Rerolls

Part 1: 0

Part 2: 0

#### Tokens Spent

Part 1: 0

Part 2: 0

### Tokens Earned

2

### Retrospective

XXC.23 Day 5: Breaks

_This post is an entry documenting my journey working through the Advent of Code 2023 challenges using my Xtreme Xmas Code mod_

Gimme a break! (Give my CPU one too)

Challenge Modifier: "Your challenge is to write a program to complete today's puzzle while taking a 3-minute (minimum) break every 20 minutes"

That was pretty fun!

I added this modifier in to help encourage players to practice mindfulness of their bodies and take more breaks. It is good that I rolled this modifier because among my goals for Advent of Code this year are to worry less about doing the puzzles in a quickly and to take better care of my mind/body/spirit.

Paradoxically, at times I found myself rushing more because I knew I'd have to take a break in X number of minutes!

So I think the takeaway here is that breaks are a good thing, but that I prefer to have less rigidity, so staying mindful of taking breaks but not adhering to a rigid schedule may be the best option.

Funny note - in Part 2 I lazily hard-coded the seed ranges for the test input, intending to come back later to code them properly for the challenge input. When I finished my main code, I had forgotten about adjusting the seed ranges and just ran the program. While I was waiting for it to finish, I got bored and decided to optimize my algorithm.

The funny part is that if I had coded the seed ranges properly from the start, my non-optimized code would have actually gotten the the correct answer before I got bored waiting for it to finish and decided to optimize it!

It turns out that my non-optimized code would have gotten the correct answer in a little over 24.2 million iterations. Many posters on Reddit had gotten solutions after tens- or hundreds-of-millions of iterations. My optimized code got the correct answer in just _2_ iterations ðŸ˜Ž

If the the answer had been different (i.e. the input data was different but was in a similar shape), my non-optimized algorithm could have taken around 2.4 billion cycles to get the correct answer in a worst-case scenario. In similar circumstances, I estimate my optimized algorithm to have a worst case of about 240 cycles.

In any case, I had fun playing with this algorithm!
